rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // helpers
    function teamDoc(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId));
    }
    function isSignedIn() {
      return request.auth != null;
    }
    function isTeamOwner(teamId) {
      return isSignedIn() && request.auth.uid == teamDoc(teamId).data.createdBy;
    }
    function isTeamMember(teamId) {
      return isSignedIn() && request.auth.uid in teamDoc(teamId).data.members;
    }
    function isTeamPublic(teamId) {
      return teamDoc(teamId).data.isPublic == true;
    }
    function validTimelineCreate(data) {
      return data.keys().hasOnly(['title','content','createdAt','createdBy']) &&
             data.createdBy == request.auth.uid &&
             ((data.title is string) || (data.content is string));
    }

    // Team timeline: teams/{teamId}/timeline/{entryId}
    match /teams/{teamId}/timeline/{entryId} {
      // Anyone can read if the team is public; otherwise only members
      allow get, list: if isTeamPublic(teamId) || isTeamMember(teamId);

      // Only the team owner can create/delete
      allow create: if isTeamOwner(teamId) && validTimelineCreate(request.resource.data);
      allow delete: if isTeamOwner(teamId);

      // Optional: allow owner to edit only title/content (not author/timestamps)
      allow update: if isTeamOwner(teamId) &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['title','content']) &&
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.createdAt == resource.data.createdAt;
    }

    // ----------------------------------------------------
    // USERS Collection
    // ----------------------------------------------------
    match /users/{userId} {
      // Restrict reads to self (avoid exposing plan/Stripe fields to other users)
      allow read: if request.auth != null && request.auth.uid == userId;

      allow create, delete: if request.auth != null
        && request.auth.uid == userId;

      allow update: if request.auth != null
        && request.auth.uid == userId
        && request.writeFields.hasOnly([
          'displayName',
          'photoURL',
          'preferences.languagePreference',
          'preferences.themePreference',
          'preferences.gloveModePreference'
        ])
        && request.resource.data.preferences is map;

      match /skis/{skiId} {
        allow read: if request.auth != null
          && request.auth.uid == userId;

        allow create: if request.auth != null
          && request.auth.uid == userId
          && (
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'athlete'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 48)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'coach'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 200)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'company'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 5000)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'free'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 12)
          )
          && !('locked' in request.resource.data);

        // Remove duplicate 'archived' and keep a strict allow-list
        allow update: if request.auth != null
          && request.auth.uid == userId
          && (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'serialNumber',
            'style',
            'brand',
            'model',
            'length',
            'stiffness',
            'base',
            'construction',
            'grind',
            'grindDate',
            'comment',
            'grindHistory',
            'dateAdded',
            'newGrind',
            'newGrindDate',
            'testIds',
            'archived',
            'skiType',
            'keywords_en',
            'keywords_no'
          ]));

        allow delete: if request.auth != null
          && request.auth.uid == userId;
      }

      match /testResults/{testId} {
        allow read, write, delete: if request.auth != null
          && request.auth.uid == userId;
      }
    }

    // ----------------------------------------------------
    // CONTACT Collection
    // ----------------------------------------------------
    // CONTACT â€” create-only; no client reads/updates/deletes
    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }
    match /contact/{contactId} {
      // If you want to allow non-auth users to submit the public form in
      // [app/(public)/contact/page.jsx](app/(public)/contact/page.jsx) via
      // [hooks/useContactForm.jsx](hooks/useContactForm.jsx), allow create for anyone:
      allow create: if request.resource.data.keys().hasOnly(['email','subject','message','userId','createdAt'])
        && request.resource.data.email is string
        && request.resource.data.subject is string
        && request.resource.data.message is string;
      allow read, update, delete: if isAdmin(); // or `false` to deny to all clients
    }

    // ----------------------------------------------------
    // TEAMS Collection
    // ----------------------------------------------------
    match /teams/{teamId} {
      function isCoachOrCompany() {
        return request.auth != null
          && (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.plan in ['coach','company']);
      }
      function isTeamCreator() {
        return request.auth != null
          && request.auth.uid == resource.data.createdBy;
      }

      allow create: if isCoachOrCompany();

      allow read: if resource.data.isPublic == true
        || (request.auth != null && request.auth.uid in resource.data.members);

      allow update, delete: if isTeamCreator();

      match /events/{eventId} {
        function isTeamMember() {
          return request.auth != null
            && (request.auth.uid in get(/databases/$(database)/documents/teams/$(teamId)).data.members);
        }

        allow create: if isTeamMember() && isCoachOrCompany();
        allow read: if isTeamMember();
        allow update, delete: if isTeamMember() && isCoachOrCompany();

        match /testResults/{testId} {
          allow read: if isTeamMember();
          allow create: if isTeamMember();
          // tighten: only coach/company can modify or delete shared results
          allow update, delete: if isTeamMember() && isCoachOrCompany();
        }
      }

      match /joinRequests/{requestId} {
        function teamCreator() {
          return request.auth != null
            && request.auth.uid == get(/databases/$(database)/documents/teams/$(teamId)).data.createdBy;
        }

        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status == "pending";

        // Read by requester or team creator
        allow read: if request.auth != null && (
          request.auth.uid == resource.data.userId || teamCreator()
        );

        // Only team creator can change status; restrict fields strictly
        allow update: if teamCreator()
          && request.writeFields.hasOnly(['status','respondedAt'])
          && (request.resource.data.status in ['approved','declined'])
          && (request.resource.data.userId == resource.data.userId);

        // Allow requester to delete their own request; team creator can also delete
        allow delete: if request.auth != null && (
          request.auth.uid == resource.data.userId || teamCreator()
        );
      }
    }
  }
}