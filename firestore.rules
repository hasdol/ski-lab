rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function teamDoc(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId));
    }
    function isSignedIn() { return request.auth != null; }
    function isTeamOwner(teamId) {
      return isSignedIn() && request.auth.uid == teamDoc(teamId).data.createdBy;
    }
    function isTeamMember(teamId) {
      return isSignedIn() && request.auth.uid in teamDoc(teamId).data.members;
    }
    function isTeamPublic(teamId) {
      return teamDoc(teamId).data.isPublic == true;
    }
    function validTimelineCreate(data) {
      return data.keys().hasOnly(['title','content','createdAt','createdBy']) &&
             data.createdBy == request.auth.uid &&
             ((data.title is string) || (data.content is string));
    }
    // Mods/helpers
    function isTeamMod(teamId) {
      return isSignedIn() && (request.auth.uid in teamDoc(teamId).data.mods);
    }
    function isStaff(teamId) { return isTeamOwner(teamId) || isTeamMod(teamId); }

    // NEW: sharing helpers
    function hasShareAccess(userId) {
      return request.auth != null
        && exists(/databases/$(database)/documents/userShares/$(userId + "_" + request.auth.uid));
    }

    function hasWriteAccess(userId) {
      return hasShareAccess(userId)
        && get(/databases/$(database)/documents/userShares/$(userId + "_" + request.auth.uid)).data.accessLevel == 'write';
    }

    // Allow listing/reading requests only for the two parties
    match /shareRequests/{reqId} {
      allow create: if request.auth != null
        && request.resource.data.keys().hasOnly(['fromUid','toUid','status','createdAt','respondedAt','fromDisplayName','toDisplayName'])
        && request.resource.data.fromUid == request.auth.uid
        && request.resource.data.status == 'pending';
      allow read: if request.auth != null
        && (request.auth.uid == resource.data.fromUid || request.auth.uid == resource.data.toUid);
      // Only the target (toUid) can accept/decline; status-only change
      allow update: if request.auth != null
        && request.auth.uid == resource.data.toUid
        && request.writeFields.hasOnly(['status','respondedAt'])
        && (request.resource.data.status in ['approved','declined'])
        && request.resource.data.fromUid == resource.data.fromUid
        && request.resource.data.toUid == resource.data.toUid;
      // Either party can delete their request (optional)
      allow delete: if request.auth != null
        && (request.auth.uid == resource.data.fromUid || request.auth.uid == resource.data.toUid);
    }

    // Active share mapping: userShares/{ownerUid_readerUid} => { ownerUid, readerUid, createdAt }
    // Writes happen via Cloud Functions (admin privileges); clients can read own relationships.
    match /userShares/{pairId} {
      allow read: if request.auth != null
        && (request.auth.uid == resource.data.ownerUid || request.auth.uid == resource.data.readerUid);
      allow create, update, delete: if false;
    }

    // USERS
    match /users/{userId} {
      // Allow owner or readers (via sharing) to read the user profile doc
      allow read: if (request.auth != null && request.auth.uid == userId) || hasShareAccess(userId);
      allow create, delete: if request.auth != null && request.auth.uid == userId;

      allow update: if request.auth != null
        && request.auth.uid == userId
        && request.writeFields.hasOnly([
          'displayName',
          'photoURL',
          'preferences.languagePreference',
          'preferences.themePreference',
          'preferences.gloveModePreference',
          'shareCode' // allow CF to merge; owner can’t directly set (no client write anyway)
        ])
        && request.resource.data.preferences is map;

      match /skis/{skiId} {
        // ✅ Owner can read all skis (including locked).
        // ✅ Shared readers can only read unlocked skis.
        allow read: if (request.auth != null && request.auth.uid == userId)
          || (hasShareAccess(userId) && resource.data.locked != true);

        // create/delete remain owner-only (as you already have)
        allow create: if request.auth != null
          && request.auth.uid == userId
          && (
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'senior'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 16)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'senior_pluss'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 32)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'coach'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 64)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'company'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 5000)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'free'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 8)
          )
          && !('locked' in request.resource.data);

        // NEW: owner-only delete (allowed even if locked)
        allow delete: if request.auth != null && request.auth.uid == userId;

        // ✅ Block editing locked skis (owner can still delete them).
        // ✅ Allow writers to update unlocked skis (e.g. adding testIds)
        allow update: if request.auth != null
          && request.auth.uid == userId
          && resource.data.locked != true
          && (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'serialNumber',
            'style',
            'brand',
            'model',
            'length',
            'stiffness',
            'stiffnessHalf',
            'stiffnessFull',
            'base',
            'construction',
            'grind',
            'grindDate',
            'comment',
            'grindHistory',
            'dateAdded',
            'newGrind',
            'newGrindDate',
            'testIds',
            'archived',
            'skiType',
            'keywords_en',
            'keywords_no'
          ]));

        // ✅ Shared writer: may ONLY update testIds (for back-referencing new tests)
        allow update: if request.auth != null
          && hasWriteAccess(userId)
          && resource.data.locked != true
          && request.writeFields.hasOnly(['testIds']);
      }

      match /testResults/{testId} {
        // Owner or authorized reader can read
        allow read: if (request.auth != null && request.auth.uid == userId)
          || hasShareAccess(userId);

        // ✅ Allow owner OR shared writer to CREATE a new test result
        allow create: if request.auth != null
          && (request.auth.uid == userId || hasWriteAccess(userId));

        // ✅ Only owner can edit/delete test results
        allow update, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // CONTACT
    function isAdmin() { return request.auth != null && request.auth.token.admin == true; }
    match /contact/{contactId} {
      allow create: if request.resource.data.keys().hasOnly(['email','subject','message','userId','createdAt','category','status'])
        && request.resource.data.email is string
        && request.resource.data.subject is string
        && request.resource.data.message is string
        && request.resource.data.category in ['support','feature','billing','other']
        && request.resource.data.status == 'open';
      allow read, update, delete: if isAdmin();
    }

    // TEAMS
    match /teams/{teamId} {
      function isCoachOrCompany() {
        return request.auth != null
          && (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.plan in ['coach','company']);
      }

      function isAdminLocal() {
        return request.auth != null && request.auth.token.admin == true;
      }

      // The team "owner" plan controls whether the team can create new events.
      function teamOwnerAllowsTeams(teamId) {
        return isAdminLocal()
          || (
            get(/databases/$(database)/documents/users/$(teamDoc(teamId).data.createdBy)).data.plan
              in ['coach','company','admin']
          );
      }
      function isTeamCreator() { return request.auth != null && request.auth.uid == teamDoc(teamId).data.createdBy; }
      function isTeamModLocal() { return request.auth != null && (request.auth.uid in teamDoc(teamId).data.mods); }
      function isStaffLocal() { return isTeamCreator() || isTeamModLocal(); }

      function teamWritableKeysOwner() {
        return ['name','imageURL','isPublic','keywords_en'];
      }
      function teamWritableKeysMod() {
        return ['name','imageURL','isPublic'];
      }

      allow create: if isCoachOrCompany();

      allow read: if resource.data.isPublic == true
        || (request.auth != null && request.auth.uid in resource.data.members)
        || isTeamCreator()
        || isTeamModLocal();

      allow update: if isTeamCreator()
        && request.writeFields.hasOnly(teamWritableKeysOwner());
      allow update: if isTeamModLocal()
        && request.writeFields.hasOnly(teamWritableKeysMod());

      allow delete: if isTeamCreator();

      match /events/{eventId} {
        function isTeamMemberLocal() {
          return request.auth != null && (request.auth.uid in teamDoc(teamId).data.members);
        }
        function eventStaffOnly(teamId, eventId) {
          return get(/databases/$(database)/documents/teams/$(teamId)/events/$(eventId)).data.resultsVisibility == 'staff';
        }

        // Creating new events requires a team-capable plan on the team owner.
        allow create: if isStaffLocal() && teamOwnerAllowsTeams(teamId);
        allow read: if isTeamMemberLocal() || isStaffLocal();
        allow update, delete: if isStaffLocal();

        match /testResults/{testId} {
          allow read: if
            isStaffLocal()
            || (!eventStaffOnly(teamId, eventId) && isTeamMemberLocal())
            || (request.auth != null && resource.data.userId == request.auth.uid);

          allow create: if isTeamMemberLocal()
            && request.auth != null
            && request.resource.data.userId == request.auth.uid;

          allow update, delete: if isStaffLocal()
            || (request.auth != null && resource.data.userId == request.auth.uid);
        }
      }

      // Team timeline (Info tab)
      match /timeline/{entryId} {
        allow read: if isTeamMember(teamId) || isStaff(teamId);
        allow create: if isStaff(teamId)
          && validTimelineCreate(request.resource.data);
        allow update: if isStaff(teamId)
          && request.writeFields.hasOnly(['title','content']);
        allow delete: if isStaff(teamId);
      }

      match /joinRequests/{requestId} {
        function teamCreator() { return request.auth != null && request.auth.uid == teamDoc(teamId).data.createdBy; }
        function teamMod() { return request.auth != null && (request.auth.uid in teamDoc(teamId).data.mods); }
        function staff() { return teamCreator() || teamMod(); }

        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status == "pending";

        allow read: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );

        allow update: if staff()
          && request.writeFields.hasOnly(['status','respondedAt'])
          && (request.resource.data.status in ['approved','declined'])
          && (request.resource.data.userId == resource.data.userId);

        allow delete: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );
      }
    }
  }
}