rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function teamDoc(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId));
    }
    function isSignedIn() {
      return request.auth != null;
    }
    function isTeamOwner(teamId) {
      return isSignedIn() && request.auth.uid == teamDoc(teamId).data.createdBy;
    }
    function isTeamMember(teamId) {
      return isSignedIn() && request.auth.uid in teamDoc(teamId).data.members;
    }
    function isTeamPublic(teamId) {
      return teamDoc(teamId).data.isPublic == true;
    }
    function validTimelineCreate(data) {
      return data.keys().hasOnly(['title','content','createdAt','createdBy']) &&
             data.createdBy == request.auth.uid &&
             ((data.title is string) || (data.content is string));
    }
    // NEW: mod + staff helpers for timeline scope
    function isTeamMod(teamId) {
      return isSignedIn() && (request.auth.uid in teamDoc(teamId).data.mods);
    }
    function isStaff(teamId) {
      return isTeamOwner(teamId) || isTeamMod(teamId);
    }

    // Timeline (mods now allowed)
    match /teams/{teamId}/timeline/{entryId} {
      allow get, list: if isTeamPublic(teamId) || isTeamMember(teamId) || isTeamOwner(teamId);
      allow create: if isStaff(teamId) && validTimelineCreate(request.resource.data);
      allow update: if isStaff(teamId)
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['title','content'])
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if isStaff(teamId);
    }

    // USERS (unchanged)
    match /users/{userId} {
      // Restrict reads to self (avoid exposing plan/Stripe fields to other users)
      allow read: if request.auth != null && request.auth.uid == userId;

      allow create, delete: if request.auth != null
        && request.auth.uid == userId;

      allow update: if request.auth != null
        && request.auth.uid == userId
        && request.writeFields.hasOnly([
          'displayName',
          'photoURL',
          'preferences.languagePreference',
          'preferences.themePreference',
          'preferences.gloveModePreference'
        ])
        && request.resource.data.preferences is map;

      match /skis/{skiId} {
        allow read: if request.auth != null
          && request.auth.uid == userId;

        allow create: if request.auth != null
          && request.auth.uid == userId
          && (
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'athlete'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 48)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'coach'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 200)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'company'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 5000)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'free'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 12)
          )
          && !('locked' in request.resource.data);

        // Remove duplicate 'archived' and keep a strict allow-list
        allow update: if request.auth != null
          && request.auth.uid == userId
          && (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'serialNumber',
            'style',
            'brand',
            'model',
            'length',
            'stiffness',
            'base',
            'construction',
            'grind',
            'grindDate',
            'comment',
            'grindHistory',
            'dateAdded',
            'newGrind',
            'newGrindDate',
            'testIds',
            'archived',
            'skiType',
            'keywords_en',
            'keywords_no'
          ]));

        allow delete: if request.auth != null
          && request.auth.uid == userId;
      }

      match /testResults/{testId} {
        allow read, write, delete: if request.auth != null
          && request.auth.uid == userId;
      }
    }

    // ----------------------------------------------------
    // CONTACT Collection
    // ----------------------------------------------------
    // CONTACT â€” create-only; no client reads/updates/deletes
    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }
    match /contact/{contactId} {
      // If you want to allow non-auth users to submit the public form in
      // [app/(public)/contact/page.jsx](app/(public)/contact/page.jsx) via
      // [hooks/useContactForm.jsx](hooks/useContactForm.jsx), allow create for anyone:
      allow create: if request.resource.data.keys().hasOnly(['email','subject','message','userId','createdAt'])
        && request.resource.data.email is string
        && request.resource.data.subject is string
        && request.resource.data.message is string;
      allow read, update, delete: if isAdmin(); // or `false` to deny to all clients
    }

    // ----------------------------------------------------
    // TEAMS Collection
    // ----------------------------------------------------
    match /teams/{teamId} {
      function isCoachOrCompany() {
        return request.auth != null
          && (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.plan in ['coach','company']);
      }
      // FIX: use teamDoc(teamId) instead of resource (which becomes child doc in nested matches)
      function isTeamCreator() {
        return request.auth != null
          && request.auth.uid == teamDoc(teamId).data.createdBy;
      }
      function isTeamMod(teamId) {
        return request.auth != null
          && (request.auth.uid in teamDoc(teamId).data.mods);
      }
      function isStaff(teamId) {
        return isTeamCreator() || isTeamMod(teamId);
      }
      function resultsVisibilityStaffOnly(teamId) {
        return teamDoc(teamId).data.resultsVisibility == 'staff';
      }

      allow create: if isCoachOrCompany();

      // Add mods to read access
      allow read: if resource.data.isPublic == true
        || (request.auth != null && request.auth.uid in resource.data.members)
        || isTeamCreator()
        || isTeamMod(teamId);

      // Update: owner full; mods limited (cannot alter owner, mods array, or remove owner from members)
      allow update: if isTeamCreator()
        || (isTeamMod(teamId)
          && request.resource.data.createdBy == resource.data.createdBy
          && request.resource.data.mods == resource.data.mods
          && (teamDoc(teamId).data.createdBy in request.resource.data.members));

      // Delete: owner only
      allow delete: if isTeamCreator();

      match /events/{eventId} {
        function isTeamMember() {
          return request.auth != null
            && (request.auth.uid in teamDoc(teamId).data.members);
        }

        // Staff (owner or mod) manage events
        allow create: if isStaff(teamId);
        allow read: if isTeamMember() || isStaff(teamId);
        allow update, delete: if isStaff(teamId);

        match /testResults/{testId} {
          // Visibility logic:
          //  - Staff always read
          //  - If visibility = team (not staff-only) any member reads
          //  - Test owner always reads own result
            allow read: if
              isStaff(teamId)
              || (!resultsVisibilityStaffOnly(teamId) && isTeamMember())
              || (request.auth != null && resource.data.userId == request.auth.uid);

            allow create: if isTeamMember();
            // Staff or owner of the shared test can update/delete
            allow update, delete: if isStaff(teamId)
              || (request.auth != null && resource.data.userId == request.auth.uid);
        }
      }

      match /joinRequests/{requestId} {
        function teamCreator() {
          return request.auth != null
            && request.auth.uid == teamDoc(teamId).data.createdBy;
        }
        function teamMod() {
          return request.auth != null
            && (request.auth.uid in teamDoc(teamId).data.mods);
        }
        function staff() { return teamCreator() || teamMod(); }

        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status == "pending";

        allow read: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );

        allow update: if staff()
          && request.writeFields.hasOnly(['status','respondedAt'])
          && (request.resource.data.status in ['approved','declined'])
          && (request.resource.data.userId == resource.data.userId);

        allow delete: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );
      }
    }
  }
}