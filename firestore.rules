rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function teamDoc(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId));
    }
    function isSignedIn() { return request.auth != null; }
    function isTeamOwner(teamId) {
      return isSignedIn() && request.auth.uid == teamDoc(teamId).data.createdBy;
    }
    function isTeamMember(teamId) {
      return isSignedIn() && request.auth.uid in teamDoc(teamId).data.members;
    }
    function isTeamPublic(teamId) {
      return teamDoc(teamId).data.isPublic == true;
    }
    function validTimelineCreate(data) {
      return data.keys().hasOnly(['title','content','createdAt','createdBy']) &&
             data.createdBy == request.auth.uid &&
             ((data.title is string) || (data.content is string));
    }
    // Mods/helpers
    function isTeamMod(teamId) {
      return isSignedIn() && (request.auth.uid in teamDoc(teamId).data.mods);
    }
    function isStaff(teamId) { return isTeamOwner(teamId) || isTeamMod(teamId); }

    // Timeline (mods allowed)
    match /teams/{teamId}/timeline/{entryId} {
      allow get, list: if isTeamPublic(teamId) || isTeamMember(teamId) || isTeamOwner(teamId);
      allow create: if isStaff(teamId) && validTimelineCreate(request.resource.data);
      allow update: if isStaff(teamId)
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['title','content'])
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if isStaff(teamId);
    }

    // USERS
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create, delete: if request.auth != null && request.auth.uid == userId;

      allow update: if request.auth != null
        && request.auth.uid == userId
        && request.writeFields.hasOnly([
          'displayName',
          'photoURL',
          'preferences.languagePreference',
          'preferences.themePreference',
          'preferences.gloveModePreference'
        ])
        && request.resource.data.preferences is map;

      match /skis/{skiId} {
        allow read: if request.auth != null && request.auth.uid == userId;

        allow create: if request.auth != null
          && request.auth.uid == userId
          && (
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'athlete'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 48)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'coach'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 200)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'company'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 5000)
            ||
            (get(/databases/$(database)/documents/users/$(userId)).data.plan == 'free'
              && get(/databases/$(database)/documents/users/$(userId)).data.skiCount < 12)
          )
          && !('locked' in request.resource.data);

        allow update: if request.auth != null
          && request.auth.uid == userId
          && (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'serialNumber',
            'style',
            'brand',
            'model',
            'length',
            'stiffness',
            'base',
            'construction',
            'grind',
            'grindDate',
            'comment',
            'grindHistory',
            'dateAdded',
            'newGrind',
            'newGrindDate',
            'testIds',
            'archived',
            'skiType',
            'keywords_en',
            'keywords_no'
          ]));

        allow delete: if request.auth != null && request.auth.uid == userId;
      }

      match /testResults/{testId} {
        allow read, write, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // CONTACT
    function isAdmin() { return request.auth != null && request.auth.token.admin == true; }
    match /contact/{contactId} {
      allow create: if request.resource.data.keys().hasOnly(['email','subject','message','userId','createdAt','category','status'])
        && request.resource.data.email is string
        && request.resource.data.subject is string
        && request.resource.data.message is string
        && request.resource.data.category in ['support','feature','billing','other']
        && request.resource.data.status == 'open';
      allow read, update, delete: if isAdmin();
    }

    // TEAMS
    match /teams/{teamId} {
      function isCoachOrCompany() {
        return request.auth != null
          && (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.plan in ['coach','company']);
      }
      function isTeamCreator() { return request.auth != null && request.auth.uid == teamDoc(teamId).data.createdBy; }
      function isTeamModLocal() { return request.auth != null && (request.auth.uid in teamDoc(teamId).data.mods); }
      function isStaffLocal() { return isTeamCreator() || isTeamModLocal(); }

      // Only CFs mutate membership/mods; disallow client writes to these fields.
      function teamWritableKeysOwner() {
        return ['name','imageURL','isPublic','keywords_en'];
      }
      function teamWritableKeysMod() {
        return ['name','imageURL','isPublic']; // mods can't touch keywords_en directly if you prefer
      }

      allow create: if isCoachOrCompany();

      allow read: if resource.data.isPublic == true
        || (request.auth != null && request.auth.uid in resource.data.members)
        || isTeamCreator()
        || isTeamModLocal();

      // Owner can update only safe fields
      allow update: if isTeamCreator()
        && request.writeFields.hasOnly(teamWritableKeysOwner());

      // Mods can update even fewer fields
      allow update: if isTeamModLocal()
        && request.writeFields.hasOnly(teamWritableKeysMod());

      // Delete: owner only
      allow delete: if isTeamCreator();

      match /events/{eventId} {
        function isTeamMemberLocal() {
          return request.auth != null && (request.auth.uid in teamDoc(teamId).data.members);
        }
        function eventStaffOnly(teamId, eventId) {
          return get(/databases/$(database)/documents/teams/$(teamId)/events/$(eventId)).data.resultsVisibility == 'staff';
        }

        // Staff manage events; members can read
        allow create: if isStaffLocal();
        allow read: if isTeamMemberLocal() || isStaffLocal();
        allow update, delete: if isStaffLocal();

        match /testResults/{testId} {
          // Staff always; if event visibility == team, any member; owner of test always
          allow read: if
            isStaffLocal()
            || (!eventStaffOnly(teamId, eventId) && isTeamMemberLocal())
            || (request.auth != null && resource.data.userId == request.auth.uid);

          // Members can create only their own test result
          allow create: if isTeamMemberLocal()
            && request.auth != null
            && request.resource.data.userId == request.auth.uid;

          // Staff or owner can update/delete
          allow update, delete: if isStaffLocal()
            || (request.auth != null && resource.data.userId == request.auth.uid);
        }
      }

      match /joinRequests/{requestId} {
        function teamCreator() { return request.auth != null && request.auth.uid == teamDoc(teamId).data.createdBy; }
        function teamMod() { return request.auth != null && (request.auth.uid in teamDoc(teamId).data.mods); }
        function staff() { return teamCreator() || teamMod(); }

        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status == "pending";

        allow read: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );

        allow update: if staff()
          && request.writeFields.hasOnly(['status','respondedAt'])
          && (request.resource.data.status in ['approved','declined'])
          && (request.resource.data.userId == resource.data.userId);

        allow delete: if request.auth != null && (
          request.auth.uid == resource.data.userId || staff()
        );
      }
    }
  }
}